<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

<script>

/*
d3.js slider..
*/

$('#content').append($('<div/>').attr('id','slider').css({'position':'absolute','bottom':'20px','opacity':'0','transition':'opacity 0.3s','z-index':'2000'}))
$('#content').append($('<div/>').attr('id','slider_value').css({'position':'absolute','bottom':'-10px','z-index':'2000'}))
$('#content').append($('<div/>').attr('id','current_diapo').css({'z-index':'1500'}))
$("#slider_value").hide() //

// Show slider on hover - with extended hover zone around the slider itself
$('#slider').hover(
    function() { $(this).css('opacity', '1') },  // Mouse enter
    function() { $(this).css('opacity', '0') }   // Mouse leave
)

// Extend the hover zone with padding to make it easier to trigger
$('#slider').css({
    'padding-top': '30px',
    'padding-bottom': '30px',
    'margin-top': '-30px',
    'margin-bottom': '-30px'
})


var currentSliderX = 0;

function css_miniature(elem, xPos){

      /*
      Css for miniature - centers thumbnail image above slider button
      Thumbnail dimensions: viewport scaled by 0.21 (0.3 * 0.7)
      To center horizontally: subtract half width from button position
      */

      // Calculate thumbnail dimensions (0.21 scale = 0.3 * 0.7)
      var thumbWidth = {{viewport_width}} * 0.21
      var thumbHeight = {{viewport_height}} * 0.21

      // Calculate top position: screen height - slider bottom - gap - thumbnail height
      var topPos = window.innerHeight - 20 - 50 - thumbHeight - 80

      elem.css({'position':'absolute',
                'top': topPos + 'px',
                'left': xPos - (thumbWidth / 2)
              })

}

var lastDiapoShown = null;
var updateTimer = null;

function show_target_diapo(d3){

      /*
      Miniature of the target diapo - optimized with debouncing
      */

      var targetDiapo = numdiap();

      // Extract the diapo number from the name (e.g., "d5" -> "5")
      var diapoNum = targetDiapo.slice(1);

      // Don't update if it's the same diapo
      if (targetDiapo === lastDiapoShown) {
          // Still update position even if same diapo
          css_miniature($('#current_diapo'), currentSliderX);
          return;
      }

      lastDiapoShown = targetDiapo;

      var elem = $('#current_diapo');

      // Update thumbnail image src with diapo number
      var thumbnail = $('#thumb_preview');
      var thumbnailUrl = '/thumbnails/thumb_{}.png'.format(diapoNum);
      if (thumbnail.length > 0) {
          thumbnail.attr('src', thumbnailUrl);
          $('#diapo_title').text(targetDiapo);
      } else {
          // Create thumbnail image with title (0.21x scale = 0.3 * 0.7)
          var thumbW = {{viewport_width}} * 0.21
          var thumbH = {{viewport_height}} * 0.21
          var thumb_part = '<img id="thumb_preview" src="{}" style="width:{}px;height:{}px;border:2px solid #ccc;box-shadow:0 4px 8px rgba(0,0,0,0.3)">'.format(thumbnailUrl, thumbW, thumbH);
          var title_part = '<br><center><h3 id="diapo_title" style="margin-top:8px;margin-bottom:20px;color:#333;font-size:14px">{}</h3></center>'.format(targetDiapo);
          elem.html(thumb_part + title_part);
      }

      // Always apply miniature CSS to update position
      css_miniature(elem, currentSliderX);

}

function show_target_diapo_debounced(d3){
      // Clear existing timer
      if (updateTimer) {
          clearTimeout(updateTimer);
      }

      // Set new timer - only update after 100ms of no movement
      updateTimer = setTimeout(function() {
          show_target_diapo(d3);
      }, 100);
}

var drag_slider = d3.behavior.drag()
    .origin(function(d) { return d })
    .on("dragstart", dragstarted)
    .on("drag", function(d) {
        if (d.dir == "x"){
            // Constrain x position between xbar (left limit) and xbar + slength (right limit)
            var constrainedX = Math.max(d.xbar, Math.min(d3.event.x, d.xbar + d.slength));
            currentSliderX = constrainedX;  // Store current slider position
            d.action();
            show_target_diapo_debounced(d3)
            return d3.select(this).attr("cx", d.x = constrainedX);
            }
        else if (d.dir == "y"){
            // Constrain y position between ybar (top limit) and ybar + slength (bottom limit)
            var constrainedY = Math.max(d.ybar, Math.min(d3.event.y, d.ybar + d.slength));
            $("#slider_value").html(constrainedY);
            d.action();
            return d3.select(this).attr("cy", d.y = constrainedY);
            }
    })
    .on("dragend", function(d) {
        // Clear debounce timer and show immediately on drag end
        if (updateTimer) {
            clearTimeout(updateTimer);
        }
        show_target_diapo(d3);
        dragended.call(this, d);
    });

var length_slider = 1000

// Calculate SVG width to fill screen width minus margins
var svgWidth = window.innerWidth - 100  // Leave 100px margin on right

var svg = d3.select("#slider")
            .append("svg")
            .attr("width", svgWidth)
            .attr("height", 100);

var chgx = function(){$("#slider_value").html(d3.event.x)}
var chgy = function(){$("#slider_value").html(d3.event.y)}

var slide = function(data, name_svg){              // Vertical or horizontal slider

    slider_line = function(data){
          var svg_slider_line = name_svg
            .selectAll("svg_slider_line")
            .data(data)
            .enter()
            .append("line")
            .attr('x1', function(d){return d.xbar}) //
            .attr('y1', function(d){return d.ybar})
            .attr('x2', function(d){if ( d.dir=="x" ){ return d.slength + d.xbar } else { return d.xbar }}) //
            .attr('y2', function(d){if ( d.dir=="y" ){ return d.slength + d.ybar } else { return d.ybar }})
            .attr('stroke', function(d){return d.col})
            .attr('stroke-width', '4px')
        }

    slider_button = function(data){
        //alert(data)
        //data = data.slice(-1)
        var slider_butt = name_svg
          .selectAll("svg_slider_button")
          .data(data)
          .enter()
          .append("ellipse")       // attach an ellipse
          .attr("cx", function(d){return d.x})           // position the x-centre
          .attr("cy", function(d){return d.y})           // position the y-centre
          .attr("rx", 7)           // set the x radius
          .attr("ry", 7)           // set the y radius
          .attr("fill", function(d){return d.col})
          .attr("class", "slide")
          .call(drag_slider);
        }
    slider_line(data);
    slider_button(data);
}

function dragstarted(d) {
    d3.event.sourceEvent.stopPropagation();
    d3.select(this).classed("dragging", true);
}

function dragended(d) {
    d3.select(this).classed("dragging", false);
    var newdiap = numdiap()
    //alert("ooooooopsssss")
    socket.emit('numdiap', newdiap.slice(1)) // send new num of diap..
    window.location.href = newdiap;  // passes to another slide..
    }

function numdiap(){

    /*
    Return the num of the current diapo..
    */

    var sliderValue = parseFloat($("#slider_value").html())
    // Subtract the offset (150px) before calculating diapo number
    // Use actual slider length (window.innerWidth - 300) instead of fixed 1000
    var actualSliderLength = window.innerWidth - 300
    var slide_number = parseInt((sliderValue - 150)/actualSliderLength*(diapo_max - 1))
    // Constrain to valid range [0, diapo_max-1]
    slide_number = Math.max(0, Math.min(slide_number, diapo_max - 1))
    var name_diap = 'd' + slide_number

    return name_diap
}

// Handle window resize (including fullscreen changes)
window.addEventListener('resize', function() {
    // Recalculate slider dimensions
    var newSliderLength = window.innerWidth - 300
    var newSvgWidth = window.innerWidth - 100

    // Update SVG width
    svg.attr("width", newSvgWidth)

    // Update slider line length
    d3.selectAll("line")
        .attr('x2', function(d) {
            if (d && d.dir == "x") {
                d.slength = newSliderLength
                return d.xbar + newSliderLength
            }
            return d3.select(this).attr('x2')
        })

    // Recalculate button position to maintain same diapo
    if (typeof diapo_index !== 'undefined' && typeof diapo_max !== 'undefined') {
        var newSliderX = 150 + diapo_index * newSliderLength / (diapo_max - 1)

        // Update button position
        d3.selectAll("ellipse.slide")
            .attr("cx", function(d) {
                if (d && d.dir == "x") {
                    d.x = newSliderX
                    d.slength = newSliderLength
                }
                return d.x
            })

        // Update slider_value
        $('#slider_value').html(newSliderX)
    }
})

</script>
